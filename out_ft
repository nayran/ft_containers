Iterator
	Iterator++: 0 10 20 30 40 50 60 70 80 90 
	Reverse iterator++: 90 80 70 60 50 40 30 20 10 0 

Iterator traits
	Tag test: random-access iterator
	it == it2
	it != it2

Iterator functions
	First element in mylist is: 0, distance until end: 10
	Sixth element in mylist is: 50, distance until end: 5
	Last element in mylist is: 90, distance until end: 1


ALGORITHM
Equal and Lexicographical_compare
	Equal: apple x apple
		Default comparison: 1
		Custom comparison: 1
	Equal: apple x apartment
		Default comparison: 0
		Custom comparison: 0
	Lexico: apple x apartment
		Default comparison: 0
		Custom comparison: 0
	Lexico: apartment x apple
		Default comparison: 1
		Custom comparison: 1


TYPE_TRAITS
Enable_if and is_integral
	enable_if::is_odd(1): 1
	enable_if::is_even(1): 0
	is_integral<char>::value: 1
	is_integral<float>::value: 0
VECTOR
VEC: 16 2 77 29 
Second: 100 100 100 100 100 100 100 
	Vector operator = 
aux: 100 100 100 100 100 100 100 
aux = vec: 16 2 77 29 
aux = aux2: 100 100 100 100 100 100 100 

	Vector capacity
Size: 4
Max_size: 4611686018427387903
Resize(5): 5
16 2 77 29 0 
Resize(7, 5): 7
16 2 77 29 0 5 5 Capacity: 8

Resize(4): 4
16 2 77 29 
Empty:0	Empty:1
Capacity: 8
Reserve new capacity (10): 10

	Element access
vec[2]: 77
vec.at(2): 77
vec.front(): 16
vec.back(): 29

	Modifiers
assign range(vec.begin(), vec.end()): 16 2 77 29 
assign fill(5, 1):	1 1 1 1 1 
push_back(2):		1 1 1 1 1 2 Capacity: 10

pop_back():		1 1 1 1 1 
push_back(1) empty vector: 1 Capacity: 1

pop_back() empty vector: 
insert single: insert(a.begin(), 300), insert(a.begin(), 100, insert(a.begin() + 1, 200))
Capacity: 4
100 200 250 300 
insert single: a.insert(it[1], 110) -- inicio no iterador retornado
110 200 250 300 
insert single: a.insert(it[1], 110) -- mostra todo o vector
100 110 200 250 300 
insert fill: a.insert(it[1], 2, 101)
100 101 101 110 200 250 300 Capacity: 8

insert range: a.insert(a.begin() + 3, i, i + 3)	 i = {105, 106, 107}
100 101 101 105 106 107 110 200 250 300 Capacity: 10

erase single element: a.erase(a.begin() + 3) -- inicio do iterador retornado
106 107 110 200 250 300 
erase single element: a.erase(a.begin() + 3) -- mostra todo o vector
100 101 101 106 107 110 200 250 300 Capacity: 10

erase range: a.erase(a.begin() + 1, a.begin() + 4) -- inicio do iterador retornado
107 110 200 250 300 
erase range: a.erase(a.begin() + 1, a.begin() + 4) -- mostra todo o vector
100 107 110 200 250 300 
Swap
before VEC: 16 2 77 29 
before Second: 1 1 1 1 1 

VEC: 1 1 1 1 1 
Second: 16 2 77 29 
AUX: 1 1 1 1 1 
vec == aux: 1
vec == second: 0
vec != second: 1
vec != aux: 0
vec < second: 1
vec <= second: 1
vec <= aux: 1
vec > aux: 0
vec <= second: 0
vec <= aux: 1

Public swap
before VEC: 1 1 1 1 1 
before Second: 16 2 77 29 
VEC: 16 2 77 29 
Second: 1 1 1 1 1 

STACK:

top
stack.top(): 29

empty and size
teste.empty(): 1
teste.size(): 0
stack.empty(): 0
stack.size(): 4

stack.push(99); stack.top(): 99 stack.size(): 5
stack.pop(); stack.top(): 29 stack.size(): 4

Relational operators
stack == stack2: 1
stack == auxstack: 0
stack != auxstack: 1
stack < auxstack: 0
stack <= auxstack: 0
stack <= stack2: 1
stack > stack2: 1
stack <= auxstack: 1
stack <= stack2: 1


UTILITY

Pair
pair.first: 42	pair.second: 3.1415
pair2.first: 42	pair2.second: 3.1415
pair3.first: 42	pair3.second: 13
pair == pair2: 1
pair == pair3: 0
pair != pair2: 0
pair != pair3: 1
pair < pair2: 0
pair < pair3: 1
pair <= pair2: 1
pair <= pair2: 1
pair > pair2: 0
pair > pair3: 0
pair >= pair2: 1
pair >= pair3: 0
p = pair: 42 3

Make pair
mkpair.first: 1	mkpair.second: 2


MAP:


Time: 0
